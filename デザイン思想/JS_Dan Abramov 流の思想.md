# Dan Abramov Style Guide for JS/React

目的：
- UIコードを「状態 → UI の計算」として捉え、予測可能で変更容易な実装を継続的に出力する。
- “動けばOK”ではなく、人間の理解コストと将来の変更コストを最小化する。

---

## 0. メンタルモデル（最重要）

- UI は「状態(state)の関数」である。UIは“更新”ではなく“再計算”される。
- 再レンダーはいつでも起こり得る。レンダー回数・タイミング前提の設計をしない。
- 関数コンポーネントは「そのレンダー時点の値」を閉じ込める（クロージャ）。常に最新を参照する前提は禁止。
- 副作用(effect)は「状態と外部世界を同期する仕組み」。ライフサイクルの穴埋めとして扱わない。

この前提を破る実装を提案しない。

---

## 1. コーディング方針（優先順位）

優先度A（必須）
1) 予測可能性（state変化の原因と結果が追える）
2) ローカリティ（変更の影響範囲が狭い）
3) 削除可能性（不要なら消せる。抽象化で結合しない）
4) 透明性（デバッグ時に追跡しやすい）

優先度B（できれば）
- パフォーマンス最適化は「測定後」。先に memo/useMemo/useCallback を乱用しない。

---

## 2. 具体ルール（Do / Don’t）

### 2.1 レンダー（純粋性を保つ）
Do:
- render中は「計算」に徹する。props/stateからUIを導出する。
- derived data はまず render 内で計算。必要になったら `useMemo` に昇格。
- 分岐は “状態” を中心に組む（UIの状態遷移が読めるように）。

Don’t:
- render中に副作用（fetch, localStorage書き込み, subscription, analytics送信）。
- render中に時間依存（Date.nowで条件分岐、setTimeoutを仕込む等）。

### 2.2 State設計（“最小”で“意味のある単位”）
Do:
- state は「最小限」かつ「UI/振る舞いの源泉」だけを持つ。
- 重複したstateを持たない（例：items と filteredItems を両方持つ、など）。
- 複雑な遷移は `useReducer` を検討（イベント→状態遷移が明確になる）。

Don’t:
- “キャッシュっぽいstate” をとりあえず増やす。
- 複数箇所で同じ真実を持つ（Single Source of Truth を壊す）。

### 2.3 Effect（同期として扱う）
Do:
- effectは「外部世界」との同期だけに使う（通信、購読、DOM API、タイマー等）。
- 依存配列は “契約”。不足させて誤魔化さない。
- cleanupは「購読解除・タイマー解除・中断」。必ず対応する。

Don’t:
- “一回だけ動かしたい” を理由に依存配列を空にして逃げる（根本設計を見直す）。
- effectで state を無理に組み立てる（それは derived か reducer で扱うことが多い）。

### 2.4 抽象化（遅らせる）
Do:
- まず素直に書く。複製が「痛み」になってから共通化する。
- 抽象化は“削除可能性”を上げる方向だけに行う（局所性を壊さない）。

Don’t:
- 先回りの汎用フック・汎用ユーティリティの量産。
- 「きれい」に見せるためだけの抽象（結合度が上がるなら逆効果）。

### 2.5 Redux等の導入（宗教化しない）
Do:
- 状態が「予測不能」になってから導入検討。
- 何を得て何を失うか（複雑さ vs 予測可能性）を説明して選ぶ。

Don’t:
- “有名だから” で最初から入れる。

---

## 3. 実装テンプレ（推奨パターン）

### 3.1 Derived data は state ではなく計算で
Bad:
- state に derived を保存し、同期ズレが起きる構造

Good:
- stateは source のみにして、renderで derived を計算

### 3.2 複雑なUI遷移は useReducer
- イベント（USER_SUBMITTED / FETCH_SUCCEEDED 等）を明示
- 状態遷移を純粋関数に寄せる

### 3.3 外部同期は effect + cleanup
- subscriptionは必ず解除
- 依存は契約として正確に

---

## 4. Claude Code の出力要件（必須）

実装を出すとき、必ず次を添える：

1) 状態設計の説明（Single Source of Truth をどこに置いたか）
2) derived data の扱い（stateにしなかった理由）
3) effect が「同期」になっている根拠（何と何を同期しているか）
4) 抽象化判断（今は抽象化しない/する理由）
5) 変更容易性（どこを変えれば要件変更できるか）

---

## 5. 実装前チェックリスト（自動セルフレビュー）

- [ ] renderは純粋か（副作用なし）
- [ ] stateは最小か（重複/キャッシュstateなし）
- [ ] derivedは計算か（stateに入れていないか）
- [ ] effectは同期か（依存配列が契約として正しいか）
- [ ] 先回り抽象化をしていないか（削除可能性が落ちていないか）
- [ ] パフォーマンス最適化は測定後か（memo乱用していないか）

---

## 6. 文章トーン（出力方針）

- “Reactの作法”ではなく「メンタルモデル→設計→実装」の順に説明する。
- 結論だけでなく、なぜその形が予測可能性と変更容易性を上げるかを短く明示する。

---

以上のルールに反する提案をする場合は、例外理由と代替案を提示すること。
（例：外部制約、既存アーキテクチャ、性能測定結果など）
